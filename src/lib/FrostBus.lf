target Python

import FrostReactor from "FrostReactor.lf"

reactor FrostBus extends FrostReactor{
    state routing_map = {= {} =}
    // state messages_out = {= {} =}

    state bus_node = {=  self.data_model.get_node("FrostBus")  =}
    state number_of_machines = {= self.data_model.get_node("FrostBus/#Machines") =}
    state machine_info_nodes = {= self.data_model.get_node("FrostBus/MachineInfo") =}

    method register_machine(message, index){=
        """Register a machine to the bus.

        Args:
            message: The incoming handshake message.
            index: The index representing the sender in the communication list.
        """
        assert message.header.matches(MsgType.REQUEST, MsgNamespace.PROTOCOL, ProtocolMsgName.REGISTER), (
            f"Invalid header: {message.header}"
        )
        # Register sender to the map.
        self.routing_map[message.sender] = index

        # Add the machine to the routing map.
        machine_info = FolderNode(name = message.sender)
        self.machine_info_nodes.add_child(machine_info)
        machine_info.add_child(
            NumericalVariableNode(
                name = "Index",
                description = "Index of the machine in the bus",
                value = index,
            )
        )
        self.logger.info(f"FrostBus register machine {message.sender}, with index {index}.")

        # Increment the number of machines.
        self.number_of_machines.value += 1

        # Return a response message to acknowledge the registration.
        return FrostMessage(
            sender=self.name,
            target=message.sender,
            identifier=str(uuid.uuid4()),
            header=FrostHeader(
                type=MsgType.RESPONSE,
                version=(1, 0, 0),
                namespace=MsgNamespace.PROTOCOL,
                msg_name=ProtocolMsgName.REGISTER,
            ),
            payload=ProtocolPayload(),
        )
    =}

    method process_messages(messages, index, out_messages){=
        """Process a list of messages and route them accordingly.
        
        Args:
            messages (list): A list of FrostMessage instances to be processed.
            index (int): The index of the port from which the messages were received.
            out_messages (dict): A dictionary mapping target indices to lists of messages to be sent out.
        """
        
        # list of messages to be sent out
        for message in messages:
            if not isinstance(message, Message):
                raise TypeError(f"Expected a Message instance, got {type(message)}")

            if message.header.namespace == MsgNamespace.PROTOCOL and message.header.msg_name == ProtocolMsgName.REGISTER:
                ack_response = self.register_machine(message, index)
                out_messages[self.routing_map[ack_response.target]].append(ack_response)
                continue

            if message.target not in self.routing_map:
                self.logger.warning(f"Cannot route message {message} to unknown target {message.target}.")
                continue

            out_messages[self.routing_map[message.target]].append(message)
    =}

    reaction(channel_in)-> channel_out{=
        """Handle incoming messages from the frost reactors and route them accordingly.
        Messages can be delivered to the bus or to a specific machine, after its registration to the bus.
        """
        out_messages = {
            i: [] for i in range(self.width)
        }

        for i, port in enumerate(channel_in):
            if not port.is_present:
                continue

            messages = port.value
            if not isinstance(messages, list):
                if not isinstance(messages, Message):
                    raise TypeError(f"Expected a list of Message instances or a single Message, got {type(messages)}")
                messages = [messages]

            self.process_messages(messages, i, out_messages)

        for target_index, messages in out_messages.items():
            if not messages:
                continue

            # TODO: remove copy from here. The messages should be immutable.
            channel_out[target_index].set(messages.copy())
            self.logger.debug(f"FrostBus sent {len(messages)} messages to target {messages[0].target} at index {target_index}.")
    =}

    reaction(startup) {=
        self.number_of_machines.value = 0
    =}

}