target Python

reactor Model(model_path = ""){

    state path = model_path
    state name
    state busy
    state registered_to_bus

    input  channel_in
    output channel_out

    state data_model = {= DataModelBuilder().get_data_model(self.path) =}
    state protocol_mng = {= GlacierProtocolMng(self.data_model) =}
    state message_queue = {= [GlacierMessage] =}

    timer check_update(1s, 1s)
    timer work(1s, 1s)
    logical action check_bus_registration
    logical action durable_method
    logical action durable_method_end
    logical action handle_update

    method generate_bus_registration_message(){=
        """
        Generates a `REGISTER` message to initiate the registration process with the CommonBus.

        This method constructs a `GlacierMessage` that requests registration in the 
        communication system. The message is addressed to the `"CommonBus"` and follows 
        the `PROTOCOL` namespace with the `REGISTER` message name.

        :return: A `GlacierMessage` representing the registration request.
        """
        return GlacierMessage(
            sender=self.name,
            target="CommonBus",
            identifier=str(uuid.uuid4()),
            header=GlacierHeader(
                type=MsgType.REQUEST,
                version=(1, 0, 0),
                namespace=MsgNamespace.PROTOCOL,
                msg_name=ProtocolMsgName.REGISTER,
            ),
            payload=ProtocolPayload(),
        )
    =}

    reaction(check_bus_registration)->channel_out,check_bus_registration{=
        '''
        If the registered_to_bus is not completed, send a registered_to_bus message to the bus
        After 9 seconds, raise an exception
        '''
        if not self.registered_to_bus:
            if lf.time.logical_elapsed() > SEC(9):
                raise Exception(f"Handshake failed:{self.name} unable to connect to the bus")
            # Generate and send the bus registration message.
            channel_out.set(self.generate_bus_registration_message())
            # Re-schedule the check in 3 seconds.
            check_bus_registration.schedule(SEC(3))
    =}

    reaction(startup)-> channel_out,check_bus_registration{=
        '''
        Initialize the model and internal variables
        Send an initial registered_to_bus message to the bus
        '''
        self.registered_to_bus = False
        self.busy = False
        self.message_queue = []
        self.name = (self.path.split("/")[-1]).split(".")[0]
        # Generate and send the bus registration message.
        channel_out.set(self.generate_bus_registration_message())
        # Schedule the check in 3 seconds.
        check_bus_registration.schedule(SEC(3))
    =}

    reaction(channel_in)->channel_out,check_bus_registration,durable_method,handle_update{=
        '''
        Handle incoming messages from the bus
        First check if the message is a durable method, if so, schedule it to be executed
        Second check if the message is an update message, if so, schedule it to be handled
        Otherwise, handle the message and generate a response (This one used for most of the cases)
        Once the response is generated, append it to the message queue
        Send the message queue to the bus
        '''
        messages = channel_in.value
        assert isinstance(messages, list) and all(isinstance(item, Message) for item in messages), "Expected a list of Message instances"

        for message in messages:
            if isinstance(message, GlacierMessage):

                if message.header.namespace == MsgNamespace.METHOD and self.data_model.get_node(message.payload.node).is_durable():
                    durable_method.schedule(0, message)

                elif message.header.namespace == MsgNamespace.VARIABLE and message.header.msg_name == VariableMsgName.UPDATE:
                    handle_update.schedule(0, message)

                elif message.header.matches(MsgType.RESPONSE, MsgNamespace.PROTOCOL, ProtocolMsgName.REGISTER):
                    logging.debug(f"Machine {self.name}, correctly registered with the CommonBus.")
                    self.registered_to_bus = True
    
                else:
                    response_message = self.protocol_mng.handle_message(message)
                    self.message_queue.append(response_message)

        if self.message_queue:
            channel_out.set(self.message_queue)
            self.message_queue = []
        
    =}

    reaction(durable_method_end)-> channel_out{=
        '''
        When the durable method prodocues a result, send it to the bus
        '''
        channel_out.set([durable_method_end.value])
    =}


    reaction(check_update)-> channel_out{=
        '''
        Check if there are any changes in the data model and send an update message to the bus
        '''
        update_messages = list(self.protocol_mng.get_update_messages())
        if update_messages:  
            channel_out.set(update_messages)
            self.protocol_mng.clear_update_messages()
            
    =}

}