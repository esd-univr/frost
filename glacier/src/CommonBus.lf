target Python

reactor CommonBus(width = 1){
    state name = "CommonBus"
    input[width] machine_in
    output[width] machine_out
    state map = {={str: int}=}
    state messages_out = {={}=}

    method list_of_Message(messages){=
        '''
        Handle a list of messages:
        - Check if the target is in the map
        - Append the message to the corresponding target
        '''
        for msg in messages:
            assert msg.target in self.map, f"Target {message.target} not found in map"
            self.messages_out[msg.target].append(msg)
    =}

    method register_machine(message, index){=
        '''
        Handles machines that register to the bus (`REGISTER` request).

        - Validates that the message is a proper `PROTOCOL REGISTER` request.
        - Registers the sender in the communication map.
        - Ensures the sender has an output queue.
        - Sends a `REGISTER` response to acknowledge the handshake.

        :param message: The incoming handshake message.
        :param index: The index representing the sender in the communication list.
        '''
        assert message.header.matches(MsgType.REQUEST, MsgNamespace.PROTOCOL, ProtocolMsgName.REGISTER), (
            f"Invalid header: {message.header}"
        )
        # Register sender to the map.
        self.map[message.sender] = index
        # Ensure sender has an output queue.
        if message.sender not in self.messages_out:
            self.messages_out[message.sender] = []
        # Generate the correct response.
        response = GlacierMessage(
            sender="CommonBus",
            target=message.sender,
            identifier=str(uuid.uuid4()),
            header=GlacierHeader(
                type=MsgType.RESPONSE,
                version=(1, 0, 0),
                namespace=MsgNamespace.PROTOCOL,
                msg_name=ProtocolMsgName.REGISTER,
            ),
            payload=ProtocolPayload(),
        )
        # Store the response in the sender's queue.
        self.messages_out[message.sender].append(response)
        # Log the registrer operation.
        logging.debug(f"CommonBus register machine {message.sender}, with index {index}.")
    =}

    reaction(machine_in)-> machine_out{=
        '''
        Handle incoming messages from the machines:
        - Check if the message is a special message
        - Check if the target is in the map
        - Append the message to the corresponding target
        - Send the messages to the corresponding machine
        '''
        for i, port in enumerate(machine_in):
            if not port.is_present:
                continue

            message = port.value
            if isinstance(message, Message):

                # Handle requests to register to the bus.
                if message.header.matches(MsgType.REQUEST, MsgNamespace.PROTOCOL, ProtocolMsgName.REGISTER):
                    self.register_machine(message, i)
                    continue

                assert message.target in self.map, f"Target {message.target} not found in the neighborhood"
                self.messages_out[message.target].append(message)

            elif isinstance(message, list):
                self.list_of_Message(message)
            else:
                Exception(f"Unknown message header type: {type(message.header)}")

        for target, messages in self.messages_out.items():
            if not messages:
                continue
            machine_out[self.map[target]].set(messages)
            logging.debug(f"CommonBus routed {len(messages)} message{'s' if len(messages) > 1 else ''} to {target}")
            self.messages_out[target] = []
            
    =}

}